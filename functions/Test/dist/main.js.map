{"version":3,"sources":["../src/main.ts","../../../src/main.ts","../src/routes/widgets.ts"],"sourcesContent":["import { inspect } from 'node:util';\n\nimport type { Context } from '@kaibun/appwrite-fn-router/types';\nimport { createRouter, handleRequest } from '@kaibun/appwrite-fn-router';\nimport widgetsRouter from './routes/widgets.ts';\n\n// Optionally define a custom JSON response schema:\n// Already available as RouterJSONResponse from the core library\n\nfunction routes(router: ReturnType<typeof createRouter>) {\n  // TODO: test with an async/await handler as well\n\n  router.get('/', (_request, _req, res, log, _error) => {\n    // log('\\n--- Root route hit:');\n    // log(inspect(res));\n    const response = res.text('Root route hit!');\n    // log('  -');\n    // log(tracePrototypeChainOf(response));\n    // log(inspect(response, { depth: null }));\n    // log('---');\n    return response;\n  });\n\n  router.all('/widgets*', widgetsRouter.fetch);\n\n  // router.all('*', (_request, _req, res, log, _error) => {\n  //   log('\\n--- Catchall route hit:');\n  //   log(inspect(res));\n  //   const response = res.text('Catchall route!', 201, {\n  //     'Content-Type': 'text/plain',\n  //   });\n  //   log('  -');\n  //   log(tracePrototypeChainOf(response));\n  //   log(inspect(response, { depth: null }));\n  //   log('---');\n  //   const response = res.text('Catchall route!', 404, {\n  //     'Content-Type': 'text/plain',\n  //   });\n  //   return response;\n  // });\n\n  //   router.get('/hello', (req, res, _log, _error) => {\n  //     return res.json({\n  //       status: 'success',\n  //       message: 'Hello, world!',\n  //     }) satisfies ResponseObject<MyJSONResponse>;\n  //   });\n  //   router.post('/mirror', async (req, res, _log, _error) => {\n  //     const data = await req.bodyJson;\n  //     return res.json({\n  //       received: data,\n  //     });\n  //   });\n  //   router.get('/mystery', myRouteHandler);\n}\n\n// TODO: publish a lib allowing to whitelist/blacklist well-known URIs\n// CSV is available at https://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml\n// For now, let’s brute-force ignore any request starting with these paths:\nconst ignoredRoutes = ['/favicon.ico', '/robots.txt', '/.well-known/'];\n\n/**\n * Test function\n */\nexport default async (context: Context) => {\n  const { req, res, log, error } = context;\n  let greetings = `${req.method} ${req.path}`;\n  // log(inspect(req, { depth: null }));\n  // log('---\\n');\n  const ignoreRoute = ignoredRoutes.some((route) => req.path.startsWith(route));\n  if (ignoreRoute) {\n    log(greetings + ' (ignored)');\n    // TODO: abide by request’s Accept header (fallback to Content-type, then to text/plain)\n    return res.text(\"I'm a teapot\", 418);\n  }\n  log(greetings + '\\n');\n\n  const response = await handleRequest(context, routes, {\n    log: false,\n    errorLog: true,\n  });\n\n  // log('\\nFINAL RESPONSE:');\n  // log(tracePrototypeChainOf(response));\n  log(inspect(response, { depth: null }));\n  // log(response.constructor.name);\n  // log(response.constructor.toString());\n  // Object.keys(response).forEach((key) => {\n  //   log(`Key: ${key}`);\n  // });\n  // Object.getOwnPropertyNames(response).forEach((key) => {\n  //   log(`Prop: ${key}`);\n  // });\n  // log(response.statusCode.toString());\n  // log(response.body!.toString());\n  // log(JSON.stringify(response.headers));\n  // log('--- LEAVING THE FUNCTION HANDLER ---');\n  log('\\n');\n\n  return response;\n};\n","import { inspect } from 'node:util';\nimport { cors, RouterOptions, Router } from 'itty-router';\nimport type {\n  Context as AppwriteContext,\n  Request as AppwriteRequest,\n  Response as AppwriteResponse,\n  DefaultLogger,\n  ErrorLogger,\n  Options,\n  RouterJSONResponse,\n  WrapperRequestType,\n} from '../types/core';\nimport '../types/global.d.ts'; // Import global declarations\n\nconst $ = globalThis;\n\n/**\n * @internal\n */\nexport function tracePrototypeChainOf(object: object) {\n  var proto = object.constructor.prototype;\n  var result = '';\n\n  while (proto) {\n    result += ' -> ' + proto.constructor.name + '.prototype';\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  result += ' -> null';\n  return result;\n}\n\n// TODO: https://github.com/kaibun/appwrite-fn-router/issues/6\n// WrapperRequestType is now defined in types/core.ts\n\n// Creating an AutoRouter instance, adjusting types to match the Appwrite context\nexport function createRouter({\n  ...args\n}: RouterOptions<\n  WrapperRequestType,\n  [AppwriteRequest, AppwriteResponse, DefaultLogger, ErrorLogger] & any[]\n> = {}) {\n  return Router<\n    WrapperRequestType,\n    [AppwriteRequest, AppwriteResponse, DefaultLogger, ErrorLogger] & any[],\n    AppwriteResponse\n  >({\n    ...args,\n  });\n}\n\n// Exporting a function to run the router with Appwrite's context\nexport async function runRouter(\n  router: ReturnType<typeof createRouter>,\n  { req, res, log, error }: AppwriteContext\n) {\n  const { headers, method, url } = req;\n  const route = new URL(url);\n  const request = new Request(route, {\n    headers,\n    method,\n  });\n\n  // Passing along the request and misc. objects from the Appwrite context\n  const response = await router.fetch(\n    request, // IRequest\n    req, // The original Appwrite’s Request\n    res, // The original Appwrite’s Response\n    log, // The original or muted Appwrite’s DefaultLogger\n    error // The original or muted Appwrite’s ErrorLogger\n  );\n\n  return response;\n}\n\nexport async function handleRequest(\n  context: AppwriteContext,\n  // Accepting a function that receives the router instance, so the end-user\n  // may define their own routes, customize that router’s behavior, etc.\n  withRouter: (router: ReturnType<typeof createRouter>) => void,\n  options: Options = {}\n) {\n  const isNotProduction = process.env.NODE_ENV !== 'production';\n  const finalOptions = {\n    globals: options.globals ?? true,\n    env: options.env ?? true,\n    log: options.log ?? isNotProduction,\n    errorLog: options.errorLog ?? isNotProduction,\n    ...options,\n  };\n\n  let { req, res, log: apwLog, error: apwError } = context;\n  finalOptions.log && apwLog('[router] Function is starting...');\n\n  try {\n    const log = finalOptions.log ? apwLog : () => {};\n    const error = finalOptions.errorLog ? apwError : () => {};\n\n    if (finalOptions.globals) {\n      globalThis.log = log;\n      globalThis.error = error;\n    }\n    if (finalOptions.env) {\n      process.env.APPWRITE_FUNCTION_API_KEY =\n        req.headers['x-appwrite-key'] || '';\n    }\n\n    // Dynamically set allowed origins based on the environment.\n    const allowedOrigins: (string | RegExp)[] =\n      finalOptions.cors?.allowedOrigins ?? [];\n    if (process.env.NODE_ENV !== 'production') {\n      // Add development origins if not already present.\n      if (!allowedOrigins.includes('http://localhost:3001')) {\n        allowedOrigins.push('http://localhost:3001');\n      }\n      if (!allowedOrigins.includes('https://localhost:3001')) {\n        allowedOrigins.push('https://localhost:3001');\n      }\n    }\n\n    // Initialize CORS with a dynamic origin validation function.\n    // This is required because itty-router's `cors` helper does not\n    // support a mixed array of strings and RegExps.\n    const { preflight, corsify } = cors({\n      origin: (origin) => {\n        if (!origin) return;\n        for (const allowed of allowedOrigins) {\n          if (typeof allowed === 'string' && allowed === origin) {\n            return origin;\n          }\n          if (allowed instanceof RegExp && allowed.test(origin)) {\n            return origin;\n          }\n        }\n      },\n      allowMethods: finalOptions.cors?.allowMethods ?? [\n        'GET',\n        'POST',\n        'PATCH',\n        'DELETE',\n        'OPTIONS',\n      ],\n      allowHeaders: finalOptions.cors?.allowHeaders ?? [\n        'Content-Type',\n        'Authorization',\n      ],\n    });\n\n    // console.log(JSON.stringify(process.env, null, 2));\n    const router = createRouter({\n      // The `before` middleware handles preflight (OPTIONS) requests.\n      before: [\n        async (req, req_appwrite, res, log, error) => {\n          // itty-router's `preflight` expects a native `Request` object.\n          const response = preflight(req);\n          if (response) {\n            // Convert the native `Response` from `preflight` to an Appwrite-compatible response object.\n            const body = await response.text();\n            const statusCode = response.status;\n            const headers = Object.fromEntries(response.headers.entries());\n            return res.send(body, statusCode, headers);\n          }\n        },\n      ],\n      // The `finally` middleware applies CORS headers to the outgoing response.\n      finally: [\n        async (responseFromRoute, request, req_appwrite, res, log, error) => {\n          if (responseFromRoute) {\n            // Re-create a native `Response` to pass it to `corsify`.\n            // The `Response` constructor throws if a body is provided with a 204 status.\n            const nativeResponse = new Response(\n              responseFromRoute.statusCode === 204\n                ? null\n                : responseFromRoute.body,\n              {\n                status: responseFromRoute.statusCode,\n                headers: responseFromRoute.headers,\n              }\n            );\n            // `corsify` adds the necessary CORS headers to the response.\n            const corsifiedResponse = corsify(nativeResponse, request);\n\n            // Convert the final native `Response` back to an Appwrite-compatible response object.\n            const body = await corsifiedResponse.text();\n            const statusCode = corsifiedResponse.status;\n            const headers = Object.fromEntries(\n              corsifiedResponse.headers.entries()\n            );\n            return res.send(body, statusCode, headers);\n          }\n        },\n      ],\n    });\n    withRouter(router);\n\n    const rr = router.routes.map(([method, regex, handlers, path]) => [\n      method,\n      regex.toString(),\n      handlers.map((h) => h.toString()),\n      path,\n    ]);\n\n    const response = await runRouter(router, { req, res, log, error });\n\n    if (!response) {\n      // TODO: abide by request’s Accept header (fallback to Content-type, then to text/plain)\n      return res.text('Not Found', 404);\n    }\n\n    return response;\n  } catch (err) {\n    // TODO: support reporting to a monitoring service\n    finalOptions.errorLog &&\n      apwError(\n        `\\n[router] Function has failed: ${err instanceof Error ? err.stack : String(err)}`\n      );\n    const message = err instanceof Error ? err.message : String(err);\n    // if (options.onError) {\n    //   return options.onError(err);\n    // }\n    // TODO: abide by request’s Accept header (fallback to Content-type, then to text/plain)\n    if (\n      ['/json', '/ld+json'].some((type) =>\n        req.headers['content-type']?.endsWith(type)\n      )\n    ) {\n      return res.json(\n        {\n          status: 'error',\n          message,\n          // TODO: ? don’t expose \"cause\" error messages in production ?\n          error:\n            err instanceof Error && err.cause instanceof Error\n              ? err.cause.message\n              : 'Reason unknown',\n        } satisfies RouterJSONResponse,\n        500\n      );\n    }\n    return res.text(message, 500);\n  }\n}\n","import { createRouter } from '@kaibun/appwrite-fn-router';\nimport type { IRequest } from 'itty-router';\nimport type { Widget } from '../../../../types/widget';\n\n// Re-export for convenience\nexport type { Widget };\n\n/**\n * Routes nested under /widgets/\n */\nconst router = createRouter({ base: '/widgets' });\n\n// GET /widgets => List widgets\nrouter.get('/', (_request, _req, res, _log, _error) => {\n  const response = res.json({\n    items: [\n      { id: 'widget1', weight: 10, color: 'red' },\n      { id: 'widget2', weight: 20, color: 'blue' },\n    ],\n  });\n  return response;\n});\n\n// POST /widgets => Create a widget\nrouter.post('/', async (request: IRequest, req, res, _log, _error) => {\n  try {\n    const body = req.bodyJson as Partial<Widget>;\n    if (typeof body.weight !== 'number' || !body.color) {\n      return res.json(\n        {\n          code: 'VALIDATION_ERROR',\n          message: 'Missing required fields',\n          errors: ['weight and color are required'],\n        },\n        400\n      );\n    }\n    const newWidget: Widget = {\n      id: `widget-${Date.now()}`,\n      weight: body.weight,\n      color: body.color,\n    };\n    return res.json(newWidget, 201);\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      return res.json(\n        {\n          code: 'BAD_REQUEST',\n          message: 'Invalid JSON in request body',\n        },\n        400\n      );\n    }\n    _error(String(e));\n    return res.json(\n      {\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'An unexpected error occurred',\n      },\n      500\n    );\n  }\n});\n\n// GET /widgets/secret => Accessing the daily secret widget (requires Bearer token)\nrouter.get('/secret', (request: IRequest, _req, res, _log, _error) => {\n  const authHeader = request.headers.get('Authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.json({ code: 'UNAUTHORIZED', message: 'Unauthorized' }, 401);\n  }\n  return res.json({ id: 'widget-secret', weight: 200, color: 'gold' });\n});\n\n// GET /widgets/{id} => Read a specific widget\nrouter.get('/:id', (request: IRequest, _req, res, _log, _error) => {\n  const { id } = request.params;\n  if (id === 'not-found') {\n    return res.json({ code: 'NOT_FOUND', message: 'Widget not found' }, 404);\n  }\n  return res.json({ id, weight: 10, color: 'red' });\n});\n\n// PATCH /widgets/{id} => Update a widget\nrouter.patch('/:id', async (request: IRequest, req, res, _log, _error) => {\n  try {\n    const { id } = request.params;\n    if (id === 'not-found') {\n      return res.json({ code: 'NOT_FOUND', message: 'Widget not found' }, 404);\n    }\n    const body = req.bodyJson as Partial<Widget>;\n    const updatedWidget: Widget = {\n      id,\n      weight: body.weight ?? 10,\n      color: body.color ?? 'red',\n    };\n    return res.json(updatedWidget);\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      return res.json(\n        {\n          code: 'BAD_REQUEST',\n          message: 'Invalid JSON in request body',\n        },\n        400\n      );\n    }\n    _error(String(e));\n    return res.json(\n      {\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'An unexpected error occurred',\n      },\n      500\n    );\n  }\n});\n\n// DELETE /widgets/{id} => Delete a widget\nrouter.delete('/:id', (request: IRequest, _req, res, _log, _error) => {\n  const { id } = request.params;\n  if (id === 'not-found') {\n    return res.json({ code: 'NOT_FOUND', message: 'Widget not found' }, 404);\n  }\n  return res.send('', 204);\n});\n\n// POST /widgets/{id} => Analyze a widget\nrouter.post('/:id', (request: IRequest, _req, res, _log, _error) => {\n  const { id } = request.params;\n  return res.json({\n    statusCode: 200,\n    id,\n    analysis: 'This widget is amazing!',\n  });\n});\n\nexport default router;\n"],"mappings":"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","names":["router","req","res","log","error","response","router"]}