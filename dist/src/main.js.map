{"version":3,"sources":["../../src/main.ts"],"sourcesContent":["import { inspect } from 'node:util';\nimport { cors, RouterOptions, Router } from 'itty-router';\n\nimport type {\n  AFRContextArgs,\n  InternalObjects,\n  AppwriteContext,\n  AppwriteRequest,\n  AppwriteResponse,\n  DefaultLogger,\n  ErrorLogger,\n  Options,\n  FinalOptions,\n  RouterJSONResponse,\n  AFRRequest,\n  logEnableFn,\n} from '../types/core';\nimport '../types/global.d.ts'; // Import global declarations\n\nconst $ = globalThis;\n\nconst noop = (...args: any[]) => {};\nconst isBoolean = (obj: unknown): obj is boolean => typeof obj === 'boolean';\nconst isFunction = (obj: unknown): obj is CallableFunction =>\n  obj instanceof Function;\nconst isDevelopment =\n  process.env.NODE_ENV === 'development' ||\n  process.env.APP_ENV === 'development';\nconst isTest =\n  process.env.NODE_ENV === 'test' || process.env.APP_ENV === 'test';\n\n/**\n * Default log activation callback: logs are enabled only in development.\n * Users can override this by passing their own function to handleRequest.\n */\nexport const defaultLogFn: logEnableFn = (mode: 'log' | 'errorLog') =>\n  isDevelopment || isTest;\n\nconst isJSONLikeRequest = (req: AppwriteRequest) =>\n  // There so many JSON-like content types, our best bet is to be agnostic.\n  // @see https://www.iana.org/assignments/media-types/media-types.xhtml\n  req.headers['content-type']?.endsWith('+json');\n\n/**\n * @internal\n * CORS preflight middleware that’s Appwrite-compatible (to be used first in before[]).\n */\nexport async function corsPreflightMiddleware(\n  req: AppwriteRequest,\n  res: AppwriteResponse,\n  log: DefaultLogger,\n  error: ErrorLogger,\n  internals: InternalObjects & {\n    preflight: (req: Request) => Response | undefined;\n  }\n) {\n  const response = internals.preflight(internals.request);\n  if (response) {\n    const body = await response.text();\n    const statusCode = response.status;\n    const headers = Object.fromEntries(response.headers.entries());\n    return res.send(body, statusCode, headers);\n  }\n}\n\n/**\n * @internal\n * CORS finalization middleware that’s Appwrite-compatible (to be used last in finally[]).\n */\nexport async function corsFinallyMiddleware(\n  responseFromRoute: any,\n  request: AppwriteRequest,\n  res: AppwriteResponse,\n  log: DefaultLogger,\n  error: ErrorLogger,\n  internals: InternalObjects & {\n    corsify: (res: Response, req: Request) => Response;\n  }\n) {\n  if (responseFromRoute) {\n    const nativeResponse = new Response(\n      responseFromRoute.statusCode === 204 ? null : responseFromRoute.body,\n      {\n        status: responseFromRoute.statusCode,\n        headers: responseFromRoute.headers,\n      }\n    );\n    const corsifiedResponse = internals.corsify(\n      nativeResponse,\n      internals.request\n    );\n    const body = await corsifiedResponse.text();\n    const statusCode = corsifiedResponse.status;\n    const headers = Object.fromEntries(corsifiedResponse.headers.entries());\n    return res.send(body, statusCode, headers);\n  }\n}\n\n/**\n * The router propagates a standard Appwrite signature to handlers:\n * `req, res, log, error` typed as `AppwriteRequest`, `AppwriteResponse`,\n * `DefaultLogger`, `ErrorLogger` respectively.\n *\n * Internal Itty Router middlewares (e.g. preflight/corsify) can access the\n * native Request object (Fetch API) via a fifth argument corresponding to\n * `InternalObjects`.\n */\nexport function createRouter({\n  ...args\n}: RouterOptions<\n  AFRRequest,\n  [AppwriteResponse, DefaultLogger, ErrorLogger, InternalObjects] & any[]\n> = {}) {\n  return Router<\n    AFRRequest,\n    [AppwriteResponse, DefaultLogger, ErrorLogger, InternalObjects] & any[],\n    AppwriteResponse\n  >({\n    ...args,\n  });\n}\n\n/**\n * @internal\n * Normalizes Appwrite request headers as case-insensitive keys, so that you can\n * use either eg. `Authorization` or `authorization` keys in your handlers.\n */\nexport function normalizeHeaders(req: AppwriteRequest) {\n  if (!req || !req.headers || typeof req.headers !== 'object') return;\n  const normalized: Record<string, string> = {};\n  for (const k in req.headers) {\n    if (Object.prototype.hasOwnProperty.call(req.headers, k)) {\n      normalized[k.toLowerCase()] = req.headers[k];\n    }\n  }\n  req.headers = new Proxy(normalized, {\n    get(target, prop: string) {\n      if (typeof prop === 'string') {\n        return target[prop.toLowerCase()];\n      }\n      return undefined;\n    },\n    has(target, prop: string) {\n      if (typeof prop === 'string') {\n        return prop.toLowerCase() in target;\n      }\n      return false;\n    },\n    ownKeys(target) {\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      if (typeof prop === 'string' && prop.toLowerCase() in target) {\n        return Object.getOwnPropertyDescriptor(target, prop.toLowerCase());\n      }\n      return undefined;\n    },\n  });\n}\n\n/**\n * @internal\n * Builds the final options from user options and environment.\n */\nexport function buildFinalOptions(options: Options): FinalOptions {\n  return {\n    globals: options.globals ?? true,\n    env: options.env ?? true,\n    log: isBoolean(options.logs)\n      ? options.logs\n      : isFunction(options.logs)\n        ? options.logs('log')\n        : defaultLogFn('log'),\n    errorLog: isBoolean(options.logs)\n      ? options.logs\n      : isFunction(options.logs)\n        ? options.logs('errorLog')\n        : defaultLogFn('errorLog'),\n    ...options,\n  } satisfies FinalOptions;\n}\n\n/**\n * @internal\n * Propagates Appwrite logging functions to the global context, if requested.\n */\nexport function setupGlobalLoggers(\n  finalOptions: Options,\n  log: DefaultLogger,\n  error: ErrorLogger\n) {\n  if (finalOptions.globals) {\n    globalThis.log = log;\n    globalThis.error = error;\n  }\n}\n\n/**\n * @internal\n * Updates the `APPWRITE_FUNCTION_API_KEY` environment variable, if requested.\n */\nexport function setupEnvVars(finalOptions: Options, req: AppwriteRequest) {\n  if (finalOptions.env) {\n    process.env.APPWRITE_FUNCTION_API_KEY = req.headers['x-appwrite-key'] || '';\n  }\n}\n\n/**\n * @internal\n * Enables dynamic CORS configuration.\n */\nexport function buildCorsOptions(finalOptions: Options) {\n  const allowedOrigins: (string | RegExp)[] =\n    finalOptions.cors?.allowedOrigins ?? [];\n  if (isDevelopment) {\n    if (!allowedOrigins.includes('http://localhost:3001')) {\n      allowedOrigins.push('http://localhost:3001');\n    }\n    if (!allowedOrigins.includes('https://localhost:3001')) {\n      allowedOrigins.push('https://localhost:3001');\n    }\n  }\n  return {\n    origin: (origin: string) => {\n      if (!origin) return;\n      for (const allowed of allowedOrigins) {\n        if (typeof allowed === 'string' && allowed === origin) {\n          return origin;\n        }\n        if (allowed instanceof RegExp && allowed.test(origin)) {\n          return origin;\n        }\n      }\n    },\n    allowMethods: finalOptions.cors?.allowMethods ?? [\n      'GET',\n      'POST',\n      'PATCH',\n      'DELETE',\n      'OPTIONS',\n    ],\n    allowHeaders: finalOptions.cors?.allowHeaders ?? [\n      'Content-Type',\n      'Authorization',\n    ],\n  };\n}\n\n/**\n * Runs the router with the Appwrite context, as well as a native `Request` for proper CORS, etc. in the Itty router.\n */\nexport async function runRouter(\n  router: ReturnType<typeof createRouter>,\n  { req, res, log, error }: AppwriteContext\n) {\n  const { headers, method, url } = req;\n  const route = new URL(url);\n\n  // Build the nativeRequest for internal use (CORS, etc.)\n  // Node 18+ and all modern runtimes provide the global Request API\n  let nativeRequest: Request = new Request(url, { headers, method });\n\n  const response = await router.fetch(\n    req, // AppwriteRequest (an itty-router’s RequestLike object)\n    res, // AppwriteResponse\n    log, // DefaultLogger\n    error, // ErrorLogger\n    {\n      request: nativeRequest, // FetchObjects.FetchRequest i.e. a native Request object\n    } as InternalObjects\n  );\n  return response;\n}\n\n/**\n * @internal\n * Centralized error handling for uncatched exceptions stemming from the router.\n * This function may be circumvented by a custom `catch handler in `ittyOptions`.\n */\nexport function handleRequestError(\n  err: unknown,\n  options: FinalOptions,\n  req: AppwriteRequest,\n  res: AppwriteResponse,\n  log: DefaultLogger,\n  error: ErrorLogger\n) {\n  if (options.errorLog) {\n    error(`[appwrite-fn-router] handleRequestError triggered: ${inspect(err)}`);\n  }\n  const message = isDevelopment\n    ? err instanceof Error\n      ? err.message\n      : String(err)\n    : 'An error occurred during request processing the request.';\n  const errorDetails = isDevelopment\n    ? err instanceof Error && err.cause instanceof Error\n      ? err.cause.message\n      : 'Reason unknown'\n    : 'Error details are not available unless in development mode.';\n  if (isJSONLikeRequest(req)) {\n    return res.json(\n      {\n        status: 'error',\n        message,\n        error: errorDetails,\n      } satisfies RouterJSONResponse,\n      500\n    );\n  }\n  return res.text(message + ' ' + errorDetails, 500);\n}\n\n/**\n * Main entry point for handling an Appwrite function HTTP request using the router abstraction.\n *\n * This function orchestrates the full lifecycle of a request:\n *\n * - Normalizes headers for case-insensitive access.\n * - Builds the final options from user options and environment.\n * - Initializes log and error functions, and propagates them globally if requested.\n * - Updates required environment variables (e.g., Appwrite API key) if requested.\n * - Dynamically configures CORS according to environment and options.\n * - Composes middlewares (before/finally) for the router, including CORS and user-provided ones.\n * - Instantiates the router, then delegates to the user-provided `withRouter` callback to define routes.\n * - Executes the router on the request, handles the response and logging.\n * - Handles uncaught errors via handleRequestError.\n *\n * @param context   Appwrite context (req, res, log, error)\n * @param withRouter User function to define routes on the router\n * @param options   Advanced options (CORS, logs, middlewares, etc.)\n * @returns         AppwriteResponseObject generated by the router, or a formatted error\n */\nexport async function handleRequest(\n  context: AppwriteContext,\n  withRouter: (router: ReturnType<typeof createRouter>) => void,\n  options: Options = {}\n) {\n  let { req, res, log: apwLog, error: apwError } = context;\n  let finalOptions: FinalOptions = { log: false, errorLog: false };\n\n  try {\n    normalizeHeaders(req);\n\n    finalOptions = buildFinalOptions(options);\n\n    const log = finalOptions.log ? apwLog : noop;\n    const error = finalOptions.errorLog ? apwError : noop;\n\n    setupGlobalLoggers(finalOptions, log, error);\n    setupEnvVars(finalOptions, req);\n\n    const corsOptions = buildCorsOptions(finalOptions);\n    const { preflight, corsify } = cors(corsOptions);\n\n    const { ittyOptions = {} } = finalOptions;\n    const { before: userBefore = [], finally: userFinally = [] } = ittyOptions;\n\n    const before: Array<(...args: AFRContextArgs) => any> = [\n      (req, res, log, error, internals, ...args) =>\n        corsPreflightMiddleware(req, res, log, error, {\n          ...(internals || {}),\n          preflight,\n        }),\n      ...[].concat(userBefore),\n    ];\n\n    const finallyArr: Array<\n      (responseFromRoute: any, ...args: AFRContextArgs) => any\n    > = [\n      ...[].concat(userFinally),\n      (responseFromRoute, request, res, log, error, internals, ...args) =>\n        corsFinallyMiddleware(responseFromRoute, request, res, log, error, {\n          ...(internals || {}),\n          corsify,\n        }),\n    ];\n\n    const router = createRouter({\n      before,\n      finally: finallyArr,\n      ...ittyOptions, // catch, etc. sont transmis automatiquement\n    });\n\n    withRouter(router);\n    // log(\n    //   '[DEBUG] router.routes (after withRouter call):',\n    //   JSON.stringify(\n    //     router.routes,\n    //     (k, v) =>\n    //       typeof v === 'function'\n    //         ? `[Function: ${v.name || 'anonymous'}]`\n    //         : v,\n    //     2\n    //   )\n    // );\n\n    const response = await runRouter(router, { req, res, log, error });\n    if (!response) {\n      // TODO: abide by request’s Accept header (fallback to Content-type, then to text/plain)\n      return res.text('Not Found', 404);\n    }\n    return response;\n  } catch (err) {\n    // By default, in the absence of a catch handler in `ittyOptions`, itty’s\n    // Router will throw an error. This is the place to handle it.\n    // As we’re handling a thrown error which breaks free of the routing cycle,\n    // there is no `internals` object available here (e.g. no `internals.request`,\n    // although you shouldn’t need it anyway as everything about the request is\n    // readily available through `req`).\n    return handleRequestError(err, finalOptions, req, res, log, error);\n  }\n}\n"],"mappings":"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","names":["log","error","req","res"]}