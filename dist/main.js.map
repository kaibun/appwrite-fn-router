{"version":3,"sources":["../src/main.ts"],"sourcesContent":["import { inspect } from 'node:util';\nimport { cors, RouterOptions, Router } from 'itty-router';\nimport type {\n  Context as AppwriteContext,\n  Request as AppwriteRequest,\n  Response as AppwriteResponse,\n  DefaultLogger,\n  ErrorLogger,\n  Options,\n  RouterJSONResponse,\n  WrapperRequestType,\n} from '../types/core';\nimport '../types/global.d.ts'; // Import global declarations\n\nconst $ = globalThis;\n\n/**\n * @internal\n */\nexport function tracePrototypeChainOf(object: object) {\n  var proto = object.constructor.prototype;\n  var result = '';\n\n  while (proto) {\n    result += ' -> ' + proto.constructor.name + '.prototype';\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  result += ' -> null';\n  return result;\n}\n\n// TODO: https://github.com/kaibun/appwrite-fn-router/issues/6\n// WrapperRequestType is now defined in types/core.ts\n\n// Creating an AutoRouter instance, adjusting types to match the Appwrite context\nexport function createRouter({\n  ...args\n}: RouterOptions<\n  WrapperRequestType,\n  [AppwriteRequest, AppwriteResponse, DefaultLogger, ErrorLogger] & any[]\n> = {}) {\n  return Router<\n    WrapperRequestType,\n    [AppwriteRequest, AppwriteResponse, DefaultLogger, ErrorLogger] & any[],\n    AppwriteResponse\n  >({\n    ...args,\n  });\n}\n\n// Exporting a function to run the router with Appwrite's context\nexport async function runRouter(\n  router: ReturnType<typeof createRouter>,\n  { req, res, log, error }: AppwriteContext\n) {\n  const { headers, method, url } = req;\n  const route = new URL(url);\n  log('\\n[router] Running router with the following request:');\n  const request = new Request(route, {\n    headers,\n    method,\n  });\n  log(\n    JSON.stringify({\n      method,\n      route,\n      headers: JSON.stringify(headers),\n    })\n  );\n\n  // Passing along the request and misc. objects from the Appwrite context\n  const response = await router.fetch(\n    request, // IRequest\n    req, // The original Appwrite’s Request\n    res, // The original Appwrite’s Response\n    log, // The original or muted Appwrite’s DefaultLogger\n    error // The original or muted Appwrite’s ErrorLogger\n  );\n\n  log('\\n[router] Router has fetched a response.');\n  return response;\n}\n\nexport async function handleRequest(\n  context: AppwriteContext,\n  // Accepting a function that receives the router instance, so the end-user\n  // may define their own routes, customize that router’s behavior, etc.\n  withRouter: (router: ReturnType<typeof createRouter>) => void,\n  options: Options = { globals: true, env: true, log: true, errorLog: true }\n) {\n  let { req, res, log: apwLog, error: apwError } = context;\n  options.log && apwLog('[router] Function is starting...');\n\n  try {\n    const log = options.log ? apwLog : () => {};\n    const error = options.errorLog ? apwError : () => {};\n\n    if (options.globals) {\n      globalThis.log = log;\n      globalThis.error = error;\n    }\n    if (options.env) {\n      process.env.APPWRITE_FUNCTION_API_KEY =\n        req.headers['x-appwrite-key'] || '';\n    }\n\n    // Dynamically set allowed origins based on the environment.\n    const allowedOrigins: (string | RegExp)[] =\n      options.cors?.allowedOrigins ?? [];\n    if (process.env.NODE_ENV !== 'production') {\n      // Add development origins if not already present.\n      if (!allowedOrigins.includes('http://localhost:3001')) {\n        allowedOrigins.push('http://localhost:3001');\n      }\n      if (!allowedOrigins.includes('https://localhost:3001')) {\n        allowedOrigins.push('https://localhost:3001');\n      }\n    }\n\n    // Initialize CORS with a dynamic origin validation function.\n    // This is required because itty-router's `cors` helper does not\n    // support a mixed array of strings and RegExps.\n    const { preflight, corsify } = cors({\n      origin: (origin) => {\n        if (!origin) return;\n        for (const allowed of allowedOrigins) {\n          if (typeof allowed === 'string' && allowed === origin) {\n            return origin;\n          }\n          if (allowed instanceof RegExp && allowed.test(origin)) {\n            return origin;\n          }\n        }\n      },\n      allowMethods: options.cors?.allowMethods ?? [\n        'GET',\n        'POST',\n        'PATCH',\n        'DELETE',\n        'OPTIONS',\n      ],\n      allowHeaders: options.cors?.allowHeaders ?? [\n        'Content-Type',\n        'Authorization',\n      ],\n    });\n\n    // console.log(JSON.stringify(process.env, null, 2));\n    const router = createRouter({\n      // The `before` middleware handles preflight (OPTIONS) requests.\n      before: [\n        async (req, req_appwrite, res, log, error) => {\n          // itty-router's `preflight` expects a native `Request` object.\n          const response = preflight(req);\n          if (response) {\n            // Convert the native `Response` from `preflight` to an Appwrite-compatible response object.\n            const body = await response.text();\n            const statusCode = response.status;\n            const headers = Object.fromEntries(response.headers.entries());\n            return res.send(body, statusCode, headers);\n          }\n        },\n      ],\n      // The `finally` middleware applies CORS headers to the outgoing response.\n      finally: [\n        async (responseFromRoute, request, req_appwrite, res, log, error) => {\n          if (responseFromRoute) {\n            // Re-create a native `Response` to pass it to `corsify`.\n            // The `Response` constructor throws if a body is provided with a 204 status.\n            const nativeResponse = new Response(\n              responseFromRoute.statusCode === 204\n                ? null\n                : responseFromRoute.body,\n              {\n                status: responseFromRoute.statusCode,\n                headers: responseFromRoute.headers,\n              }\n            );\n            // `corsify` adds the necessary CORS headers to the response.\n            const corsifiedResponse = corsify(nativeResponse, request);\n\n            // Convert the final native `Response` back to an Appwrite-compatible response object.\n            const body = await corsifiedResponse.text();\n            const statusCode = corsifiedResponse.status;\n            const headers = Object.fromEntries(\n              corsifiedResponse.headers.entries()\n            );\n            return res.send(body, statusCode, headers);\n          }\n        },\n      ],\n    });\n    withRouter(router);\n\n    log('\\n[router] Router has been augmented with routes:');\n    const rr = router.routes.map(([method, regex, handlers, path]) => [\n      method,\n      regex.toString(),\n      handlers.map((h) => h.toString()),\n      path,\n    ]);\n    rr.forEach((r) => log(JSON.stringify(r)));\n\n    const response = await runRouter(router, { req, res, log, error });\n    apwLog('\\n[router] Router has fetched with result:');\n    apwLog(inspect(response, { depth: null }));\n\n    if (!response) {\n      // TODO: abide by request’s Accept header (fallback to Content-type, then to text/plain)\n      return res.text('Not Found', 404);\n    }\n\n    apwLog('\\n[router] Router response received');\n    // Debug: response body access would need proper Response interface handling\n    // log(tracePrototypeChainOf(response));\n    // Object.getOwnPropertyNames(response).forEach((key) => {\n    //   log(`Key: ${key}`);\n    // });\n\n    return response;\n  } catch (err) {\n    // TODO: support reporting to a monitoring service\n    options.errorLog &&\n      apwError(\n        `\\n[router] Function has failed: ${err instanceof Error ? err.stack : String(err)}`\n      );\n    const message = err instanceof Error ? err.message : String(err);\n    // if (options.onError) {\n    //   return options.onError(err);\n    // }\n    // TODO: abide by request’s Accept header (fallback to Content-type, then to text/plain)\n    if (\n      ['/json', '/ld+json'].some((type) =>\n        req.headers['content-type']?.endsWith(type)\n      )\n    ) {\n      return res.json(\n        {\n          status: 'error',\n          message,\n          // TODO: ? don’t expose \"cause\" error messages in production ?\n          error:\n            err instanceof Error && err.cause instanceof Error\n              ? err.cause.message\n              : 'Reason unknown',\n        } satisfies RouterJSONResponse,\n        500\n      );\n    }\n    return res.text(message, 500);\n  }\n}\n"],"mappings":"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","names":["req","res","log","error","response"]}