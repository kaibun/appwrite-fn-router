import { handleRequest } from '@kaibun/appwrite-fn-router';

const sdk = require('node-appwrite');

export default async function main(context) {
  const client = new sdk.Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<YOUR_PROJECT_ID>')
    .setKey('<YOUR_API_KEY>');

  const databases = new sdk.Databases(client);

  return await handleRequest(context, (router) => {
    // GET /widgets
    router.get('/widgets', async (_req, res) => {
      const result = await databases.listDocuments(
        '<DATABASE_ID>',
        '<COLLECTION_ID>'
      );
      return res.json({ items: result.documents });
    });

    // POST /widgets
    router.post('/widgets', async (req, res) => {
      const widget = req.body;
      const created = await databases.createDocument(
        '<DATABASE_ID>',
        '<COLLECTION_ID>',
        'unique()',
        widget
      );
      return res.json(created, 201);
    });

    // POST /widgets/bulk
    router.post('/widgets/bulk', async (req, res) => {
      const widgets = req.body;
      if (!Array.isArray(widgets)) {
        return res.json(
          { code: 'BAD_REQUEST', message: 'Expected an array of widgets' },
          400
        );
      }
      const created = [];
      const errors = [];
      for (const widget of widgets) {
        try {
          const doc = await databases.createDocument(
            '<DATABASE_ID>',
            '<COLLECTION_ID>',
            'unique()',
            widget
          );
          created.push(doc);
        } catch (e) {
          errors.push({ widget, error: String(e) });
        }
      }
      return res.json({ items: created, errors }, 201);
    });

    // GET /widgets/:id
    router.get('/widgets/:id', async (req, res) => {
      const { id } = req.params;
      try {
        const widget = await databases.getDocument(
          '<DATABASE_ID>',
          '<COLLECTION_ID>',
          id
        );
        return res.json(widget);
      } catch (e) {
        return res.json(
          { code: 'NOT_FOUND', message: 'Widget not found' },
          404
        );
      }
    });

    // PATCH /widgets/:id
    router.patch('/widgets/:id', async (req, res) => {
      try {
        const { id } = req.params;
        const updates = req.bodyJson;
        const updated = await databases.updateDocument(
          '<DATABASE_ID>',
          '<COLLECTION_ID>',
          id,
          updates
        );
        return res.json(updated);
      } catch (e) {
        if (e instanceof Error && e.message === 'Document not found') {
          return res.json(
            { code: 'NOT_FOUND', message: 'Widget not found' },
            404
          );
        }
        if (e instanceof SyntaxError) {
          return res.json(
            { code: 'BAD_REQUEST', message: 'Invalid JSON in request body' },
            400
          );
        }
        throw e;
      }
    });

    // DELETE /widgets/:id
    router.delete('/widgets/:id', async (req, res) => {
      const { id } = req.params;
      try {
        await databases.deleteDocument('<DATABASE_ID>', '<COLLECTION_ID>', id);
        return res.json({ deleted: true });
      } catch (e) {
        return res.json(
          { code: 'NOT_FOUND', message: 'Widget not found' },
          404
        );
      }
    });

    // DELETE /widgets
    router.delete('/widgets', async (_req, res) => {
      const result = await databases.listDocuments(
        '<DATABASE_ID>',
        '<COLLECTION_ID>'
      );
      const items = result.documents || [];
      let deleted = 0;
      // Appwrite doesn’t natively support bulk deletion, so we need to loop
      // over received items. Unfortunately, Appwrite doesn’t support
      // transactions atm (2025-08), so we better trace and report individual
      // failures.
      for (const doc of items) {
        try {
          await databases.deleteDocument(
            '<DATABASE_ID>',
            '<COLLECTION_ID>',
            doc.$id
          );
          deleted++;
        } catch (e) {
          // TODO: report errors for failed individual deletions
        }
      }
      return res.json({ deleted });
    });
  });
}
